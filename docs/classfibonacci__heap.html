<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppfibonacci: fibonacci_heap&lt; K, T, Compare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cppfibonacci
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">A C++ implementation of Fibonacci heap</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classfibonacci__heap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fibonacci_heap&lt; K, T, Compare &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A C++ implementation of Fibonacci heap.  
 <a href="classfibonacci__heap.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fibonacci_8hpp_source.html">fibonacci.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap_1_1node.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to nodes in Fibonacci heap.  <a href="classfibonacci__heap_1_1node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe6032535ed7fdb43761c33622ca02bc"><td class="memItemLeft" align="right" valign="top"><a id="afe6032535ed7fdb43761c33622ca02bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#afe6032535ed7fdb43761c33622ca02bc">fibonacci_heap</a> ()=default</td></tr>
<tr class="memdesc:afe6032535ed7fdb43761c33622ca02bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty Fibonacci heap. <br /></td></tr>
<tr class="separator:afe6032535ed7fdb43761c33622ca02bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb46218061c78fa03e7202c608fc2df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a0eb46218061c78fa03e7202c608fc2df">fibonacci_heap</a> (std::initializer_list&lt; std::tuple&lt; K, T &gt;&gt; list)</td></tr>
<tr class="memdesc:a0eb46218061c78fa03e7202c608fc2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Fibonacci heap from list of key data pairs.  <a href="#a0eb46218061c78fa03e7202c608fc2df">More...</a><br /></td></tr>
<tr class="separator:a0eb46218061c78fa03e7202c608fc2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6d2e21382b830e0cccabe2e3a39084"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a2a6d2e21382b830e0cccabe2e3a39084">fibonacci_heap</a> (const <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a> &amp;old)</td></tr>
<tr class="memdesc:a2a6d2e21382b830e0cccabe2e3a39084"><td class="mdescLeft">&#160;</td><td class="mdescRight">the copy constructor.  <a href="#a2a6d2e21382b830e0cccabe2e3a39084">More...</a><br /></td></tr>
<tr class="separator:a2a6d2e21382b830e0cccabe2e3a39084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab756a20603b9570e234d4eece5fc8821"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#ab756a20603b9570e234d4eece5fc8821">fibonacci_heap</a> (<a class="el" href="classfibonacci__heap.html">fibonacci_heap</a> &amp;&amp;old)</td></tr>
<tr class="memdesc:ab756a20603b9570e234d4eece5fc8821"><td class="mdescLeft">&#160;</td><td class="mdescRight">the move constructor.  <a href="#ab756a20603b9570e234d4eece5fc8821">More...</a><br /></td></tr>
<tr class="separator:ab756a20603b9570e234d4eece5fc8821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a8367c18061a082bab83cbce230920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfibonacci__heap.html">fibonacci_heap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a51a8367c18061a082bab83cbce230920">operator=</a> (<a class="el" href="classfibonacci__heap.html">fibonacci_heap</a> old)</td></tr>
<tr class="memdesc:a51a8367c18061a082bab83cbce230920"><td class="mdescLeft">&#160;</td><td class="mdescRight">the assignment operator, using copy-and-swap idiom  <a href="#a51a8367c18061a082bab83cbce230920">More...</a><br /></td></tr>
<tr class="separator:a51a8367c18061a082bab83cbce230920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82abbafcb2a025ba07086b7dd926428"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#aa82abbafcb2a025ba07086b7dd926428">size</a> () const</td></tr>
<tr class="memdesc:aa82abbafcb2a025ba07086b7dd926428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements stored.  <a href="#aa82abbafcb2a025ba07086b7dd926428">More...</a><br /></td></tr>
<tr class="separator:aa82abbafcb2a025ba07086b7dd926428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3578f12fa06d20c58200cd42484e1a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a3578f12fa06d20c58200cd42484e1a52">insert</a> (K key, const T &amp;data)</td></tr>
<tr class="memdesc:a3578f12fa06d20c58200cd42484e1a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element.  <a href="#a3578f12fa06d20c58200cd42484e1a52">More...</a><br /></td></tr>
<tr class="separator:a3578f12fa06d20c58200cd42484e1a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394c7e4594e6f999c5c4735ba63fc0ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a394c7e4594e6f999c5c4735ba63fc0ab">insert</a> (K key, T &amp;&amp;data)</td></tr>
<tr class="memdesc:a394c7e4594e6f999c5c4735ba63fc0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element.  <a href="#a394c7e4594e6f999c5c4735ba63fc0ab">More...</a><br /></td></tr>
<tr class="separator:a394c7e4594e6f999c5c4735ba63fc0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a0427b577ae8c4cb50b6d7e9092ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a46a0427b577ae8c4cb50b6d7e9092ae3">insert</a> (<a class="el" href="classfibonacci__heap_1_1node.html">node</a> n)</td></tr>
<tr class="memdesc:a46a0427b577ae8c4cb50b6d7e9092ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element.  <a href="#a46a0427b577ae8c4cb50b6d7e9092ae3">More...</a><br /></td></tr>
<tr class="separator:a46a0427b577ae8c4cb50b6d7e9092ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dabb78c5bd2c5831ad38952c2849ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a9dabb78c5bd2c5831ad38952c2849ad1">top</a> () const</td></tr>
<tr class="memdesc:a9dabb78c5bd2c5831ad38952c2849ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the top element.  <a href="#a9dabb78c5bd2c5831ad38952c2849ad1">More...</a><br /></td></tr>
<tr class="separator:a9dabb78c5bd2c5831ad38952c2849ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a40697a2808dbd43739f9b3cd3b606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a34a40697a2808dbd43739f9b3cd3b606">meld</a> (<a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt; &amp;fh)</td></tr>
<tr class="memdesc:a34a40697a2808dbd43739f9b3cd3b606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meld another Fibonacci heap to this Fibonacci heap.  <a href="#a34a40697a2808dbd43739f9b3cd3b606">More...</a><br /></td></tr>
<tr class="separator:a34a40697a2808dbd43739f9b3cd3b606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab337f5341b93daadef1395ea198f4cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#ab337f5341b93daadef1395ea198f4cf2">decrease_key</a> (<a class="el" href="classfibonacci__heap_1_1node.html">node</a> n, K new_key)</td></tr>
<tr class="memdesc:ab337f5341b93daadef1395ea198f4cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descrease (or increase if you use greater as Compare) the key of the given node.  <a href="#ab337f5341b93daadef1395ea198f4cf2">More...</a><br /></td></tr>
<tr class="separator:ab337f5341b93daadef1395ea198f4cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f177edbf7e25be5912f5142c64c2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a13f177edbf7e25be5912f5142c64c2fd">remove</a> ()</td></tr>
<tr class="memdesc:a13f177edbf7e25be5912f5142c64c2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the top element.  <a href="#a13f177edbf7e25be5912f5142c64c2fd">More...</a><br /></td></tr>
<tr class="separator:a13f177edbf7e25be5912f5142c64c2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b5314a81a0fea2bb915ee34a23d18c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#ad3b5314a81a0fea2bb915ee34a23d18c">remove</a> (<a class="el" href="classfibonacci__heap_1_1node.html">node</a> n)</td></tr>
<tr class="memdesc:ad3b5314a81a0fea2bb915ee34a23d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element specified by the node object.  <a href="#ad3b5314a81a0fea2bb915ee34a23d18c">More...</a><br /></td></tr>
<tr class="separator:ad3b5314a81a0fea2bb915ee34a23d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564f8ffbc398da644d451db745be5f54"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a564f8ffbc398da644d451db745be5f54">dot</a> (std::string node_format(void *address, const K &amp;key, const T &amp;data)=[](void *, const K &amp;key, const T &amp;){ return &quot;label=&quot;+std::to_string(key);}, std::string child_format=&quot;color=black&quot;, std::string parent_format=&quot;color=green&quot;, std::string right_sibling_format=&quot;color=red&quot;, std::string left_sibling_format=&quot;color=blue&quot;, std::string double_arrow_format=&quot;dir=both color=\ed:blue\) const</td></tr>
<tr class="memdesc:a564f8ffbc398da644d451db745be5f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate the graph in dot format which can be used for illustration  <a href="#a564f8ffbc398da644d451db745be5f54">More...</a><br /></td></tr>
<tr class="separator:a564f8ffbc398da644d451db745be5f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a44b67c379b04d84d3503b76cefcee608"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfibonacci__heap.html#a44b67c379b04d84d3503b76cefcee608">fibonacci_whitebox&lt; K, T, Compare &gt;</a></td></tr>
<tr class="separator:a44b67c379b04d84d3503b76cefcee608"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt;<br />
class fibonacci_heap&lt; K, T, Compare &gt;</h3>

<p>A C++ implementation of Fibonacci heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>the type for keys </td></tr>
    <tr><td class="paramname">T</td><td>the type for data </td></tr>
    <tr><td class="paramname">Compare</td><td>the class that define the order of keys, with default value the "&lt;". </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#_a0">example.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0eb46218061c78fa03e7202c608fc2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb46218061c78fa03e7202c608fc2df">&sect;&nbsp;</a></span>fibonacci_heap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::<a class="el" href="classfibonacci__heap.html">fibonacci_heap</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::tuple&lt; K, T &gt;&gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a Fibonacci heap from list of key data pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list of key data pairs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a6d2e21382b830e0cccabe2e3a39084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6d2e21382b830e0cccabe2e3a39084">&sect;&nbsp;</a></span>fibonacci_heap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::<a class="el" href="classfibonacci__heap.html">fibonacci_heap</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>old</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the copy constructor. </p>
<p>Shallow copy will mess up the data structure and therefore is not allowed. Whenever the user tries to make a copy of a <a class="el" href="classfibonacci__heap.html" title="A C++ implementation of Fibonacci heap. ">fibonacci_heap</a> object, a deep copy will be made.</p>
<p>Also note that the node objects at old Fibonacci heap can not be used at copied Fibonacci heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old</td><td>the Fibonacci heap to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab756a20603b9570e234d4eece5fc8821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab756a20603b9570e234d4eece5fc8821">&sect;&nbsp;</a></span>fibonacci_heap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::<a class="el" href="classfibonacci__heap.html">fibonacci_heap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>old</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the move constructor. </p>
<p>Move all the data from old Fibonacci heap to new one. The node objects at old Fibonacci heap can be used at new Fibonacci heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old</td><td>the Fibonacci heap to move data from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab337f5341b93daadef1395ea198f4cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab337f5341b93daadef1395ea198f4cf2">&sect;&nbsp;</a></span>decrease_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::decrease_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>new_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descrease (or increase if you use greater as Compare) the key of the given node. </p>
<p>It is the user's responsibility to make sure that the given node is actually in this Fibonacci heap. Trying to decrease a key of a node not in this Fibonacci heap will have undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the node object holding the key and data of the element to be inserted </td></tr>
    <tr><td class="paramname">new_key</td><td>the new key of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a564f8ffbc398da644d451db745be5f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564f8ffbc398da644d451db745be5f54">&sect;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">std::string &#160;</td>
          <td class="paramname"><em>node_format</em>void *address, const K &amp;key, const T &amp;data = <code>[](void&#160;*,const&#160;K&#160;&amp;key,const&#160;T&#160;&amp;){&#160;return&#160;&quot;label=&quot;+std::to_string(key);&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>child_format</em> = <code>&quot;color=black&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>parent_format</em> = <code>&quot;color=green&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>right_sibling_format</em> = <code>&quot;color=red&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>left_sibling_format</em> = <code>&quot;color=blue&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>double_arrow_format</em> = <code>&quot;dir=both&#160;color=\&quot;red:blue\&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate the graph in dot format which can be used for illustration </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_format</td><td>a function that given the pointer address, key and data of a node and returns the format string in [] for this node. Default is always returns "label=&lt;key&gt;", which means only the key will be displayed. Return a "style=invis" if you don't want to see nodes.</td></tr>
    <tr><td class="paramname">child_format</td><td>fortmat string in [] for child pointer, default "color=black", set it to "style=invis" if you don't want it to display.</td></tr>
    <tr><td class="paramname">parent_format</td><td>fortmat string in [] for parent pointer, default "color=green", set it to "style=invis" if you don't want it to display.</td></tr>
    <tr><td class="paramname">right_sibling_format</td><td>fortmat string in [] for right_sibling pointer, default "color=red", set it to "style=invis" if you don't want it to display.</td></tr>
    <tr><td class="paramname">left_sibling_format</td><td>fortmat string in [] for left_sibling pointer, default "color=blue", set it to "style=invis" if you don't want it to display.</td></tr>
    <tr><td class="paramname">double_arrow_format</td><td>to display correctly, the case that two arrows of different style has same starting and ending is a special case to handle. This happens when both left_sibling and right_sibling of a node point to itself, or when there are two elements in a sibling list. This parameter is the format string in [] for this special case. Usually you need to create a double direction arrow with colors the color for left_sibling and the color for right_sibling. Default value is "dir=both color="red:blue"".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing the dot format of this Fibonacci heap </dd></dl>

</div>
</div>
<a id="a3578f12fa06d20c58200cd42484e1a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3578f12fa06d20c58200cd42484e1a52">&sect;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap_1_1node.html">node</a> <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to be inserted </td></tr>
    <tr><td class="paramname">data</td><td>the data of the element to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node object holding the inserted element </dd></dl>

</div>
</div>
<a id="a394c7e4594e6f999c5c4735ba63fc0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394c7e4594e6f999c5c4735ba63fc0ab">&sect;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap_1_1node.html">node</a> <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to be inserted </td></tr>
    <tr><td class="paramname">value</td><td>the data of the element to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node object holding the inserted element </dd></dl>

</div>
</div>
<a id="a46a0427b577ae8c4cb50b6d7e9092ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a0427b577ae8c4cb50b6d7e9092ae3">&sect;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap_1_1node.html">node</a> <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node object holding the key and data of the element to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node object holding the inserted element </dd></dl>

</div>
</div>
<a id="a34a40697a2808dbd43739f9b3cd3b606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a40697a2808dbd43739f9b3cd3b606">&sect;&nbsp;</a></span>meld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::meld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>fh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Meld another Fibonacci heap to this Fibonacci heap. </p>
<p>After meld, all the data will be moved to this Fibonacci heap, and the parameter "fh" will become empty. After meld, both the node objects of this and the node objects of parameter "fh" will work on this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fh</td><td>the Fibonacci heap to be melded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51a8367c18061a082bab83cbce230920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a8367c18061a082bab83cbce230920">&sect;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&amp; <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;&#160;</td>
          <td class="paramname"><em>old</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the assignment operator, using copy-and-swap idiom </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old</td><td>the Fibonacci heap to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this object </dd></dl>

</div>
</div>
<a id="a13f177edbf7e25be5912f5142c64c2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f177edbf7e25be5912f5142c64c2fd">&sect;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap_1_1node.html">node</a> <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the top element. </p>
<dl class="section return"><dt>Returns</dt><dd>the removed node object </dd></dl>

</div>
</div>
<a id="ad3b5314a81a0fea2bb915ee34a23d18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b5314a81a0fea2bb915ee34a23d18c">&sect;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap_1_1node.html">node</a> <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfibonacci__heap_1_1node.html">node</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the element specified by the node object. </p>
<p>It is the user's responsibility to make sure that the given node is actually in this Fibonacci heap. Trying to remove a node not in this Fibonacci heap will have undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the node to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed node object </dd></dl>

</div>
</div>
<a id="aa82abbafcb2a025ba07086b7dd926428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82abbafcb2a025ba07086b7dd926428">&sect;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements stored. </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements stored in this Fibonacci heap </dd></dl>

</div>
</div>
<a id="a9dabb78c5bd2c5831ad38952c2849ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dabb78c5bd2c5831ad38952c2849ad1">&sect;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfibonacci__heap_1_1node.html">node</a> <a class="el" href="classfibonacci__heap.html">fibonacci_heap</a>&lt; K, T, Compare &gt;::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the top element. </p>
<dl class="section return"><dt>Returns</dt><dd>the node object on the top </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a44b67c379b04d84d3503b76cefcee608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b67c379b04d84d3503b76cefcee608">&sect;&nbsp;</a></span>fibonacci_whitebox< K, T, Compare ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, typename Compare = std::less&lt;K&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classfibonacci__whitebox.html">fibonacci_whitebox</a>&lt; K, T, Compare &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To allow user defined test class to access private members of this class, simply define the test class name as macro FIBONACCI_HEAP_TEST_FRIEND </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="fibonacci_8hpp_source.html">fibonacci.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
